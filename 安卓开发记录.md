# 安卓开发记录

## 项目创建
~~~
1.下载Android Studio安卓开发IDE工具
2.创建 Empty Views Actvity 空项目，报名建议 com.example.XXX 目的是避免重名
3.选择安卓的SDK版本，建议超过API30的新版本，使用Kotlin语音
4.等待gradle更新，gradle是用于管理安卓各类包导入的工具
~~~


## 开启虚拟机调试
~~~
1.进入 Device Manager 创建虚拟机
2.选择 Pixel 9 或新版手机，选择手机内存与性能
3.选择虚拟机的SDK版本，点击完成即可
4.开启虚拟机后调试会亮起
~~~

## 真机连接
~~~
1.UBS连接，尝试连接时不可用
2.WLAN连接，开启手机开发者模式，开启WLAN调试，在IDE中 Pair Devices Wi-Fi 扫二维码即可
~~~

## 导入新模块-toml文件-推荐
~~~
1.toml文件可以统一管理版本
2.进入项目 gradle/lib.versions.toml 文件添加内容
3.在 build.gradle.kts 文件中导入
4.修改完文件需要更新，点击右上角 Now 更新下载文件

== toml例子 ==
[versions]
ktor = "3.3.3"
bouncycastle = "1.70"
[libraries]
ktor-server-core = { group = "io.ktor", name = "ktor-server-core", version.ref = "ktor" }
bcprov-jdk15on = { group = "org.bouncycastle", name = "bcprov-jdk15on", version.ref = "bouncycastle" }

== kts例子 ==
dependencies {
    implementation(libs.ktor.server.core)
    implementation(libs.bcprov.jdk15on)
}
~~~


## 导入新模块-直接导入
~~~
1.直接写入 build.gradle.kts 即可更新下载


== kts例子 ==
dependencies {
    implementation("io.ktor:ktor-server-core:3.3.3")
}
~~~


## 开启Binding的View对象获取
~~~
1.在 build.gradle.kts 文件开启 Binding 功能
2.开启后 src/main/res/layout/main.xml 等UI文件会自动生成 MainBinding 类
3.在 MainActivity.kt中可以从 MainBinding 中获取到View对象来访问TextView对象
4.从 MainBinding 获取的id会自动变成小驼峰命名

== kts例子 ==
android {
    # 在android内写
    buildFeatures {
        viewBinding = true
    }
}

== kt例子 ==
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        mainBinding = MainBinding.inflate(layoutInflater)
        mainBinding.txtRunTime.text = "hello"
    }
}

== xml例子 ==
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    android:id="@+id/main">

    <TextView
        android:id="@+id/txt_run_time"
        app:layout_constraintStart_toStartOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
~~~


## 打包与发布
~~~
1.打包需要提前生成jks签名文件，执行脚本生成jks
2.在 build.gradle.kts 文件写入签名文件路径
3.点击IDE的菜单，Build->Generate Signed App Bundle or App->选择APK->填写jks文件路径与脚本生成对应的jks密码等信息->选择签名App输出的路径->create完成发布

== jks脚本 ==
keytool.exe -genkey -v -keystore app-release-key.jks -keyalg RSA ^
-keysize 2048 -validity 10000 -alias CPTF_APP_ALIAS -storepass CPTF_APP_PWD -keypass CPTF_APP_PWD

== kts例子 ==
android {
    # 在android内写
    signingConfigs {
            create("release") {
                storeFile = file("../app-release-key.jks")
                storePassword = "CPTF_APP_PWD"
                keyAlias = "CPTF_APP_ALIAS"
                keyPassword = "CPTF_APP_PWD"
            }
        }
}
~~~


## MainActivity程序的注意事项
~~~
1.需要在onCreate函数内创建View并设置主页面
2.每次启动页面都会触发onResume函数
3.销毁时调用onDestroy，但并非每次都调用
4.无法访问任何公开目录，只能访问内部数据目录
5.推荐使用Timber日志打印，并在Logcat内查看日志打印


== 设置主页面例子 ==
override fun onCreate(savedInstanceState: Bundle?) {
    mainBinding = MainBinding.inflate(layoutInflater)
    setContentView(mainBinding.root)
}

== 访问公开目录文件 ==
fun writeFile(content: String): Boolean {
    var fileDoc: File = Environment.getExternalStoragePublicDirectory(filePath)
    if (Environment.getExternalStorageState(fileDoc) == Environment.MEDIA_MOUNTED) {
        val file = File(fileDoc, fileName)
        file.parentFile?.mkdirs()
        file.writeText(content)
        return true
    }
    return false
}

== 访问用户授权文件 ==
registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
    uri?.let {
        var input = this.contentResolver.openInputStream(uri)
    }
}
~~~


## 权限获取
~~~
1.安卓使用时需要获取各类权限才能访问，包括文件、网络等
2.在 AndroidManifest.xml 文件中添加各类权限
3.添加http明文通信的权限例子

== AndroidManifest.xml ==
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />

    <application
        android:networkSecurityConfig="@xml/network_security_config">
    </application>
</manifest>

== network_security_config.xml ==
# 路径在 src\main\res\xml\network_security_config.xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="false">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
</network-security-config>
~~~


## View的制作规范
~~~
1.开启Binding模式
2.每一个页面创建一个xml文件，安卓内命名推荐全小写下划线模式
3.各类文件功能存在专门的放置规范，放错地方会报错
4.创建View的布局文件放入layout目录，View需要一个布局类作为根，通常为ConstraintLayout
5.View内的对象设置文本，如TextView等，文本推荐引用value内的值


== 规范 ==
anim    : 动画类
drawable: 背景类
layout  : 布局类
value   : 内容类
xml     : 配置类

== layout : main.xml ==
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    android:id="@+id/main"
    android:background="@color/background">

    <TextView
        android:id="@+id/txt_run_time"
        android:text="@string/main_run_time" />
</androidx.constraintlayout.widget.ConstraintLayout>

== value : string.xml ==
<resources>
    <string name="app_name">CopyTransfer</string>
    <string name="main_run_time">运行时间</string>
</resources>

== value : color.xml ==
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="background">#FFFF0000</color>
</resources>
~~~


## 获取系统服务
~~~
1.获取系统服务需要传入MainActivity的Context参数
3.获取剪切板监控系统服务例子

== 例子 ==
// 使用服务
override fun onCreate(savedInstanceState: Bundle?) {
    clipboardListener(this) { text ->
        Timber.d(text)
    }
}
// 创建服务
fun clipboardListener(appContext: Context,cb: (String) -> Unit): OnPrimaryClipChangedListener {
    val clipboard = appContext.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
    var listener = OnPrimaryClipChangedListener {
        val clipData = clipboard.primaryClip
        if (clipData != null) {
            val text = clipData.getItemAt(0).text.toString()
            cb(text)
        }
    }
    clipboard.addPrimaryClipChangedListener(listener)
    return listener
}
~~~


## 启动协程
~~~
1.协程是类似线程的轻量子线程
2.操作协程与操作线程类似，需要注意线程问题
3.子线程不能直接操作UI线程，需要转到UI线程


== 例子 ==
override fun onCreate(savedInstanceState: Bundle?) {
    var serverScope = CoroutineScope(Dispatchers.IO + Job())
    serverScope.launch {
        // 后台计算
        var text = backCalc()

        // 前台显示
        runOnUiThread {
            binding.viewText.text = text
        }
    }
}
~~~

## 添加Https服务器
~~~
1.推荐使用ktor服务器与客户端
2.开启https的证书验证
3.服务器需要生成jks证书
4.客户端需要下载服务器证书并验证jks证书
5.使用bouncycastle来生成jks证书
6.客户端首次与服务器通信下载jks证书时，可先忽略验证（危险操作）
7.服务器开启ssl会使用ssl新端口，服务器会占用两个端口，客户端需连接ssl端口


== 服务器步骤 ==
1.使用bouncycastle创建证书并写入.key和.crt文件
2.服务器开启时读取.key和.crt文件，写入KeyStore对象
3.传入KeyStore对象来开启ktor的ssl服务器

== 客户端步骤 ==
（可以先忽略验证比下载服务器.crt证书，后续加载完成后进行ssl通信，危险操作）
1.需要提前下载服务器生成的.crt文件
2.客户端需要读取.crt文件来生成SSLContext对象
3.传入SSLContext对象来开启ssl连接并设置服务器的ssl新端口
~~~

## 未来
~~~

~~~